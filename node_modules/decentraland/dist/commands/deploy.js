"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.failWithSpinner = exports.help = void 0;
const arg_1 = __importDefault(require("arg"));
const chalk_1 = __importDefault(require("chalk"));
const dcl_catalyst_client_1 = require("dcl-catalyst-client");
const dcl_catalyst_commons_1 = require("dcl-catalyst-commons");
const dcl_crypto_1 = require("dcl-crypto");
const schemas_1 = require("@dcl/schemas");
const opn_1 = __importDefault(require("opn"));
const isTypescriptProject_1 = require("../project/isTypescriptProject");
const sceneJson_1 = require("../sceneJson");
const Decentraland_1 = require("../lib/Decentraland");
const spinner = __importStar(require("../utils/spinner"));
const logging_1 = require("../utils/logging");
const moduleHelpers_1 = require("../utils/moduleHelpers");
const analytics_1 = require("../utils/analytics");
const utils_1 = require("../sceneJson/utils");
const errors_1 = require("../utils/errors");
const help = () => `
  Usage: ${chalk_1.default.bold('dcl build [options]')}

    ${chalk_1.default.dim('Options:')}

      -h, --help                Displays complete help
      -t, --target              Specifies the address and port for the target catalyst server. Defaults to peer.decentraland.org
      -t, --target-content      Specifies the address and port for the target content server. Example: 'peer.decentraland.org/content'. Can't be set together with --target
      --skip-version-checks     Skip the ECS and CLI version checks, avoid the warning message and launch anyway
      --skip-build              Skip build before deploy

    ${chalk_1.default.dim('Example:')}

    - Deploy your scene:

      ${chalk_1.default.green('$ dcl deploy')}

    - Deploy your scene to a specific content server:

    ${chalk_1.default.green('$ dcl deploy --target my-favorite-catalyst-server.org:2323')}
`;
exports.help = help;
function failWithSpinner(message, error) {
    spinner.fail(message);
    (0, errors_1.fail)(errors_1.ErrorType.DEPLOY_ERROR, error);
}
exports.failWithSpinner = failWithSpinner;
async function main() {
    const args = (0, arg_1.default)({
        '--help': Boolean,
        '-h': '--help',
        '--target': String,
        '-t': '--target',
        '--target-content': String,
        '-tc': '--target-content',
        '--skip-version-checks': Boolean,
        '--skip-build': Boolean,
        '--https': Boolean,
        '--force-upload': Boolean,
        '--yes': Boolean
    });
    analytics_1.Analytics.deploy();
    if (args['--target'] && args['--target-content']) {
        throw new Error(`You can't set both the 'target' and 'target-content' arguments.`);
    }
    const workDir = process.cwd();
    const skipVersionCheck = args['--skip-version-checks'];
    const skipBuild = args['--skip-build'];
    if (!skipVersionCheck) {
        await (0, moduleHelpers_1.checkECSVersions)(workDir);
    }
    spinner.create('Building scene in production mode');
    if (!(await (0, isTypescriptProject_1.isTypescriptProject)(workDir))) {
        failWithSpinner(`Please make sure that your project has a 'tsconfig.json' file.`);
    }
    if (!skipBuild) {
        try {
            await (0, moduleHelpers_1.buildTypescript)({
                workingDir: workDir,
                watch: false,
                production: true,
                silence: true
            });
            spinner.succeed('Scene built successfully');
        }
        catch (error) {
            const message = 'Build /scene in production mode failed';
            failWithSpinner(message, error);
        }
    }
    else {
        spinner.succeed();
    }
    spinner.create('Creating deployment structure');
    const dcl = new Decentraland_1.Decentraland({
        isHttps: !!args['--https'],
        workingDir: workDir,
        forceDeploy: args['--force-upload'],
        yes: args['--yes']
    });
    const project = dcl.workspace.getSingleProject();
    if (!project) {
        return failWithSpinner('Cannot deploy a workspace, please go to the project directory and run `dcl deploy` again there.');
    }
    // Obtain list of files to deploy
    let originalFilesToIgnore = await project.getDCLIgnore();
    if (originalFilesToIgnore === null) {
        originalFilesToIgnore = await project.writeDclIgnore();
    }
    let filesToIgnorePlusEntityJson = originalFilesToIgnore;
    if (!filesToIgnorePlusEntityJson.includes('entity.json')) {
        filesToIgnorePlusEntityJson =
            filesToIgnorePlusEntityJson + '\n' + 'entity.json';
    }
    const files = await project.getFiles(filesToIgnorePlusEntityJson);
    const contentFiles = new Map(files.map((file) => [file.path, file.content]));
    // Create scene.json
    const sceneJson = await (0, sceneJson_1.getSceneFile)(workDir);
    const { entityId, files: entityFiles } = await dcl_catalyst_client_1.DeploymentBuilder.buildEntity({
        type: dcl_catalyst_commons_1.EntityType.SCENE,
        pointers: findPointers(sceneJson),
        files: contentFiles,
        metadata: sceneJson
    });
    spinner.succeed('Deployment structure created.');
    //  Validate scene.json
    (0, utils_1.validateScene)(sceneJson, true);
    dcl.on('link:ready', (url) => {
        console.log(chalk_1.default.bold('You need to sign the content before the deployment:'));
        spinner.create(`Signing app ready at ${url}`);
        setTimeout(() => {
            try {
                // tslint:disable-next-line: no-floating-promises
                void (0, opn_1.default)(url);
            }
            catch (e) {
                console.log(`Unable to open browser automatically`);
            }
        }, 5000);
        dcl.on('link:success', ({ address, signature, chainId }) => {
            spinner.succeed(`Content successfully signed.`);
            console.log(`${chalk_1.default.bold('Address:')} ${address}`);
            console.log(`${chalk_1.default.bold('Signature:')} ${signature}`);
            console.log(`${chalk_1.default.bold('Network:')} ${(0, schemas_1.getChainName)(chainId)}`);
        });
    });
    // Signing message
    const messageToSign = entityId;
    const { signature, address, chainId } = await dcl.getAddressAndSignature(messageToSign);
    const authChain = dcl_crypto_1.Authenticator.createSimpleAuthChain(entityId, address, signature);
    // Uploading data
    let catalyst;
    if (args['--target']) {
        let target = args['--target'];
        if (target.endsWith('/')) {
            target = target.slice(0, -1);
        }
        catalyst = new dcl_catalyst_client_1.CatalystClient({ catalystUrl: target });
    }
    else if (args['--target-content']) {
        const targetContent = args['--target-content'];
        catalyst = new dcl_catalyst_client_1.ContentClient({ contentUrl: targetContent });
    }
    else {
        catalyst = await dcl_catalyst_client_1.CatalystClient.connectedToCatalystIn({
            network: 'mainnet'
        });
    }
    spinner.create(`Uploading data to: ${catalyst.getContentUrl()}`);
    const deployData = { entityId, files: entityFiles, authChain };
    const position = sceneJson.scene.base;
    const network = chainId === schemas_1.ChainId.ETHEREUM_ROPSTEN ? 'ropsten' : 'mainnet';
    const sceneUrl = `https://play.decentraland.org/?NETWORK=${network}&position=${position}`;
    try {
        await catalyst.deployEntity(deployData, false, { timeout: '10m' });
        spinner.succeed(`Content uploaded. ${chalk_1.default.underline.bold(sceneUrl)}`);
        analytics_1.Analytics.sceneDeploySuccess();
    }
    catch (error) {
        (0, logging_1.debug)('\n' + error.stack);
        failWithSpinner('Could not upload content', error);
    }
}
exports.main = main;
function findPointers(sceneJson) {
    return sceneJson.scene.parcels;
}
//# sourceMappingURL=deploy.js.map