"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.help = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const chalk_1 = __importDefault(require("chalk"));
const arg_1 = __importDefault(require("arg"));
const schemas_1 = require("@dcl/schemas");
const Decentraland_1 = require("../lib/Decentraland");
const analytics_1 = require("../utils/analytics");
const logging_1 = require("../utils/logging");
const errors_1 = require("../utils/errors");
const installDependencies_1 = __importDefault(require("../project/installDependencies"));
var type = schemas_1.sdk.ProjectType;
const filesystem_1 = require("../utils/filesystem");
const help = () => `
  Usage: ${chalk_1.default.bold('dcl init [options]')}

    ${chalk_1.default.dim('Options:')}

    -h, --help               Displays complete help
    -p, --project [type] Choose a projectType (default is scene). It could be any of ${chalk_1.default.bold(getProjectTypes())}

    ${chalk_1.default.dim('Examples:')}

    - Generate a new Decentraland Scene project in my-project folder

    ${chalk_1.default.green('$ dcl init my-project')}

    - Generate a new scene project

    ${chalk_1.default.green('$ dcl init --project scene')}
`;
exports.help = help;
function getProjectTypes() {
    return Object.values(type)
        .filter((a) => typeof a === 'string')
        .join(', ');
}
async function getprojectType(type) {
    if (!type) {
        const choices = [
            { value: schemas_1.sdk.ProjectType.SCENE, name: 'Scene' },
            { value: schemas_1.sdk.ProjectType.SMART_ITEM, name: 'Smart Item' },
            {
                value: schemas_1.sdk.ProjectType.PORTABLE_EXPERIENCE,
                name: 'Smart Wearable (Beta)'
            }
        ];
        const projectTypeList = [
            {
                type: 'list',
                name: 'project',
                message: 'Choose a project type',
                choices
            }
        ];
        const answers = await inquirer_1.default.prompt(projectTypeList);
        const projectType = answers.project;
        return projectType;
    }
    if (!schemas_1.sdk.ProjectType.validate(type)) {
        (0, errors_1.fail)(errors_1.ErrorType.INIT_ERROR, `Invalid projectType: "${chalk_1.default.bold(type)}". Supported types are ${chalk_1.default.bold(getProjectTypes())}`);
    }
    return type;
}
async function main() {
    const args = (0, arg_1.default)({
        '--help': Boolean,
        '--project': String,
        '-h': '--help',
        '-p': '--project'
    });
    const dcl = new Decentraland_1.Decentraland({ workingDir: process.cwd() });
    const project = dcl.workspace.getSingleProject();
    const isEmpty = await (0, filesystem_1.isEmptyDirectory)(process.cwd());
    if (!isEmpty) {
        const results = await inquirer_1.default.prompt({
            type: 'confirm',
            name: 'continue',
            message: (0, logging_1.warning)(`Project directory isn't empty. Do you want to continue?`)
        });
        if (!results.continue) {
            return;
        }
    }
    if (!project) {
        (0, errors_1.fail)(errors_1.ErrorType.INIT_ERROR, 'Cannot try to init a project in workspace directory');
        return;
    }
    await project.validateNewProject();
    const projectType = await getprojectType(args['--project']);
    await project.writeDclIgnore();
    await project.writeSceneFile({});
    await project.scaffoldProject(projectType);
    try {
        await (0, installDependencies_1.default)(dcl.getWorkingDir(), false);
    }
    catch (error) {
        (0, errors_1.fail)(errors_1.ErrorType.INIT_ERROR, error.message);
    }
    analytics_1.Analytics.sceneCreated({ projectType: projectType });
    console.log(chalk_1.default.green(`\nSuccess! Run 'dcl start' to see your scene\n`));
}
exports.main = main;
//# sourceMappingURL=init.js.map