"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decentraland = void 0;
const events_1 = require("events");
const chalk_1 = __importDefault(require("chalk"));
const ethers_1 = require("ethers");
const wildcards_1 = __importDefault(require("wildcards"));
const ContentService_1 = require("./content/ContentService");
const land_1 = require("../utils/land");
const errors_1 = require("../utils/errors");
const config_1 = require("../config");
const logging_1 = require("../utils/logging");
const Ethereum_1 = require("./Ethereum");
const LinkerAPI_1 = require("./LinkerAPI");
const Preview_1 = require("./Preview");
const API_1 = require("./API");
const Workspace_1 = require("./Workspace");
class Decentraland extends events_1.EventEmitter {
    constructor(args = {
        workingDir: process.cwd()
    }) {
        super();
        this.options = args;
        this.options.config = this.options.config || (0, config_1.getConfig)();
        console.assert(this.options.workingDir, 'Working directory is missing');
        (0, logging_1.debug)(`Working directory: ${chalk_1.default.bold(this.options.workingDir)}`);
        this.workspace = (0, Workspace_1.createWorkspace)({ workingDir: this.options.workingDir });
        this.ethereum = new Ethereum_1.Ethereum();
        this.provider = this.options.blockchain ? this.ethereum : new API_1.API();
        this.contentService = new ContentService_1.ContentService(this.options.config.catalystUrl);
        if (process.env.DCL_PRIVATE_KEY) {
            this.createWallet(process.env.DCL_PRIVATE_KEY);
        }
        // Pipe all events
        (0, wildcards_1.default)(this.ethereum, 'ethereum:*', this.pipeEvents.bind(this));
        (0, wildcards_1.default)(this.contentService, 'upload:*', this.pipeEvents.bind(this));
    }
    getWorkingDir() {
        return this.options.workingDir;
    }
    async link(rootCID) {
        const project = this.workspace.getSingleProject();
        if (!project) {
            throw new Error('Cannot link a workspace. Please set you current directory in the project folder.');
        }
        await project.validateExistingProject();
        await project.validateSceneOptions();
        return new Promise(async (resolve, reject) => {
            const linker = new LinkerAPI_1.LinkerAPI(project);
            (0, wildcards_1.default)(linker, '*', this.pipeEvents.bind(this));
            linker.on('link:success', async (message) => {
                resolve(message);
            });
            try {
                await linker.link(this.options.linkerPort, !!this.options.isHttps, rootCID);
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async preview() {
        for (const project of this.workspace.getAllProjects()) {
            await project.validateExistingProject();
            await project.validateSceneOptions();
        }
        const preview = new Preview_1.Preview(this, this.getWatch());
        (0, wildcards_1.default)(preview, '*', this.pipeEvents.bind(this));
        await preview.startServer(this.options.previewPort);
    }
    async getAddressInfo(address) {
        const [coords, estateIds] = await Promise.all([
            this.provider.getLandOf(address),
            this.provider.getEstatesOf(address)
        ]);
        const pRequests = Promise.all(coords.map((coord) => this.provider.getLandData(coord)));
        const eRequests = Promise.all(estateIds.map((estateId) => this.provider.getEstateData(estateId)));
        const [pData, eData] = await Promise.all([pRequests, eRequests]);
        const parcels = pData.map((data, i) => (Object.assign({ x: coords[i].x, y: coords[i].y }, (0, land_1.filterAndFillEmpty)(data, '')))) || [];
        const estates = eData.map((data, i) => (Object.assign({ id: parseInt(estateIds[i].toString(), 10) }, (0, land_1.filterAndFillEmpty)(data, '')))) || [];
        return { parcels, estates };
    }
    getWatch() {
        return !!this.options.watch;
    }
    async getParcelInfo(coords) {
        const [scene, land, blockchainOwner, operator, updateOperator] = await Promise.all([
            this.contentService.getSceneData(coords),
            this.provider.getLandData(coords),
            this.provider.getLandOwner(coords),
            this.provider.getLandOperator(coords),
            this.provider.getLandUpdateOperator(coords)
        ]);
        const { EstateRegistry } = (0, config_1.getConfig)();
        if (blockchainOwner !== EstateRegistry) {
            return {
                scene,
                land: Object.assign(Object.assign({}, land), { owner: blockchainOwner, operator, updateOperator })
            };
        }
        const estateId = await this.provider.getEstateIdOfLand(coords);
        const owner = await this.provider.getEstateOwner(estateId);
        return { scene, land: Object.assign(Object.assign({}, land), { owner, operator, updateOperator }) };
    }
    async getEstateInfo(estateId) {
        const estate = await this.provider.getEstateData(estateId);
        if (!estate) {
            return undefined;
        }
        const owner = await this.provider.getEstateOwner(estateId);
        const operator = await this.provider.getEstateOperator(estateId);
        const updateOperator = await this.provider.getEstateUpdateOperator(estateId);
        const parcels = await this.provider.getLandOfEstate(estateId);
        return Object.assign(Object.assign({}, estate), { owner, operator, updateOperator, parcels });
    }
    async getEstateOfParcel(coords) {
        const estateId = await this.provider.getEstateIdOfLand(coords);
        if (!estateId || estateId < 1) {
            return undefined;
        }
        return this.getEstateInfo(estateId);
    }
    getParcelStatus(x, y) {
        return this.contentService.getParcelStatus({ x, y });
    }
    async getPublicAddress() {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        return (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.getAddress();
    }
    async getAddressAndSignature(messageToSign) {
        if (this.wallet) {
            const [signature, address] = await Promise.all([
                this.wallet.signMessage(messageToSign),
                this.wallet.getAddress()
            ]);
            return { signature, address };
        }
        return this.link(messageToSign);
    }
    pipeEvents(event, ...args) {
        this.emit(event, ...args);
    }
    createWallet(privateKey) {
        let length = 64;
        if (privateKey.startsWith('0x')) {
            length = 66;
        }
        if (privateKey.length !== length) {
            (0, errors_1.fail)(errors_1.ErrorType.DEPLOY_ERROR, 'Addresses should be 64 characters length.');
        }
        this.wallet = new ethers_1.ethers.Wallet(privateKey);
    }
}
exports.Decentraland = Decentraland;
//# sourceMappingURL=Decentraland.js.map