"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeploymentBuilder = void 0;
const hashing = __importStar(require("@dcl/hashing"));
const hashing_1 = require("@dcl/hashing");
const dcl_catalyst_commons_1 = require("dcl-catalyst-commons");
class DeploymentBuilder {
    /**
     * Take all the entity's data, build the entity file with it, and calculate its id
     */
    static async buildEntityAndFile({ type, pointers, timestamp, content, metadata }) {
        // Make sure that there is at least one pointer
        if (pointers.length === 0)
            throw new Error(`All entities must have at least one pointer.`);
        const entity = {
            // default version is V3
            version: dcl_catalyst_commons_1.EntityVersion.V3,
            type,
            pointers,
            timestamp,
            content,
            metadata
        };
        // prevent duplicated file names
        if (content) {
            const usedFilenames = new Set();
            for (let a of content) {
                const lowerCasedFileName = a.file.toLowerCase();
                if (usedFilenames.has(lowerCasedFileName)) {
                    throw new Error(`Error creating the deployable entity: Decentraland's file system is case insensitive, the file ${JSON.stringify(a.file)} is repeated`);
                }
                usedFilenames.add(lowerCasedFileName);
            }
        }
        const entityFile = new TextEncoder().encode(JSON.stringify(entity));
        const entityId = await (0, hashing_1.hashV1)(entityFile);
        const entityWithId = {
            id: entityId,
            ...entity
        };
        return { entity: entityWithId, entityFile };
    }
    /**
     * As part of the deployment process, an entity has to be built. In this method, we are building it, based on the data provided.
     * After the entity is built, the user will have to sign the entity id, to prove they are actually who they say they are.
     */
    static async buildEntity({ type, pointers, files, metadata, timestamp }) {
        // Reorder input
        const contentFiles = Array.from(files ?? []).map(([key, content]) => ({
            key,
            content
        }));
        // Calculate hashes
        const allInfo = await Promise.all(contentFiles.map(async ({ key, content }) => ({ key, content, hash: await hashing.hashV1(content) })));
        const hashesByKey = new Map(allInfo.map(({ hash, key }) => [key, hash]));
        const filesByHash = new Map(allInfo.map(({ hash, content }) => [hash, content]));
        return DeploymentBuilder.buildEntityInternal(type, pointers, {
            hashesByKey,
            filesByHash,
            metadata,
            timestamp
        });
    }
    /**
     * In cases where we don't need upload content files, we can simply generate the new entity. We can still use already uploaded hashes on this new entity.
     */
    static async buildEntityWithoutNewFiles({ type, pointers, hashesByKey, metadata, timestamp }) {
        return DeploymentBuilder.buildEntityInternal(type, pointers, { hashesByKey, metadata, timestamp });
    }
    static async buildEntityInternal(type, pointers, options) {
        // Make sure that there is at least one pointer
        if (pointers.length === 0) {
            throw new Error(`All entities must have at least one pointer.`);
        }
        // Re-organize the hashes
        const hashesByKey = options?.hashesByKey ?? new Map();
        const entityContent = Array.from(hashesByKey.entries()).map(([key, hash]) => ({
            file: key,
            hash
        }));
        // Calculate timestamp if necessary
        const timestamp = options?.timestamp ?? Date.now();
        // Build entity file
        const { entity, entityFile } = await DeploymentBuilder.buildEntityAndFile({
            type,
            pointers,
            timestamp,
            content: entityContent,
            metadata: options?.metadata
        });
        // Add entity file to content files
        const filesByHash = options?.filesByHash ?? new Map();
        filesByHash.set(entity.id, entityFile);
        return { files: filesByHash, entityId: entity.id };
    }
}
exports.DeploymentBuilder = DeploymentBuilder;
//# sourceMappingURL=DeploymentBuilder.js.map