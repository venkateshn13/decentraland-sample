import * as hashing from '@dcl/hashing';
import { ContentFileHash } from '../types';
export declare namespace Hashing {
    /**
     * Given a set of files, return a map with their hash
     * @deprecated use calculateIPFSHashes instead. This function only exists for compatibility reasons
     */
    function calculateHashes<T extends Uint8Array>(files: T[]): Promise<{
        hash: ContentFileHash;
        file: T;
    }[]>;
    /**
     * Return the given buffer's hash
     * @deprecated use calculateIPFSHash instead. This function only exists for compatibility reasons
     */
    function calculateBufferHash(buffer: Uint8Array): Promise<ContentFileHash>;
    /**
     * @deprecated use `import {hashV1} from '@dcl/hashing'` instead
     */
    function calculateIPFSHash(buffer: Uint8Array): Promise<ContentFileHash>;
    function calculateIPFSHashes<T extends Uint8Array>(files: T[]): Promise<{
        hash: ContentFileHash;
        file: T;
    }[]>;
    /**
     * Calculates the content hash of multiple files to be used consistently by the builder
     * and other content-based applications when hashes need to be stored on-chain.
     *
     * Returns the CIDv1 of the data prepared to sign
     *
     * @deprecated use `import {calculateMultipleHashesADR32} from '@dcl/hashing'` instead
     */
    const calculateMultipleHashesADR32: typeof hashing.calculateMultipleHashesADR32;
    /**
     * Calculates the content hash of multiple files to be used consistently by the builder
     * and other content-based applications when hashes need to be stored on-chain.
     * @deprecated this is maintained only for compatibility reasons with calculateBufferHash (Qm prefix)
     */
    const calculateMultipleHashesADR32LegacyQmHash: typeof hashing.calculateMultipleHashesADR32LegacyQmHash;
}
