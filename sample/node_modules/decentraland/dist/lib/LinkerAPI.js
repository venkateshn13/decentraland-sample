"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkerAPI = void 0;
const path_1 = __importDefault(require("path"));
const https_1 = __importDefault(require("https"));
const events_1 = require("events");
const url_1 = __importDefault(require("url"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const express_1 = __importDefault(require("express"));
const portfinder_1 = __importDefault(require("portfinder"));
const querystring_1 = __importDefault(require("querystring"));
const config_1 = require("../config");
const env_1 = require("../utils/env");
/**
 * Events emitted by this class:
 *
 * link:ready   - The server is up and running
 * link:success - Signatire success
 * link:error   - The transaction failed and the server was closed
 */
class LinkerAPI extends events_1.EventEmitter {
    constructor(project) {
        super();
        this.app = (0, express_1.default)();
        this.project = project;
    }
    link(port, isHttps, rootCID) {
        return new Promise(async (_resolve, reject) => {
            let resolvedPort = port;
            if (!resolvedPort) {
                try {
                    resolvedPort = await portfinder_1.default.getPortPromise();
                }
                catch (e) {
                    resolvedPort = 4044;
                }
            }
            const url = `${isHttps ? 'https' : 'http'}://localhost:${resolvedPort}/linker`;
            this.setRoutes(rootCID);
            this.on('link:error', (err) => {
                reject(err);
            });
            const serverHandler = () => this.emit('link:ready', url);
            const eventHandler = () => (e) => {
                if (e.errno === 'EADDRINUSE') {
                    reject(new Error(`Port ${resolvedPort} is already in use by another process`));
                }
                else {
                    reject(new Error(`Failed to start Linker App: ${e.message}`));
                }
            };
            if (isHttps) {
                const privateKey = await fs_extra_1.default.readFile(path_1.default.resolve(__dirname, '../../certs/localhost.key'), 'utf-8');
                const certificate = await fs_extra_1.default.readFile(path_1.default.resolve(__dirname, '../../certs/localhost.crt'), 'utf-8');
                const credentials = { key: privateKey, cert: certificate };
                const httpsServer = https_1.default.createServer(credentials, this.app);
                httpsServer
                    .listen(resolvedPort, serverHandler)
                    .on('error', eventHandler);
            }
            else {
                this.app.listen(resolvedPort, serverHandler).on('error', eventHandler);
            }
        });
    }
    setRoutes(rootCID) {
        const linkerDapp = path_1.default.resolve(__dirname, '..', '..', 'node_modules', '@dcl/linker-dapp');
        this.app.use(express_1.default.static(linkerDapp));
        this.app.get('/linker', async (_, res) => {
            const { LANDRegistry, EstateRegistry } = (0, config_1.getCustomConfig)();
            const { parcels, base: baseParcel } = (await this.project.getSceneFile())
                .scene;
            const query = querystring_1.default.stringify({
                baseParcel,
                parcels,
                rootCID,
                landRegistry: LANDRegistry,
                estateRegistry: EstateRegistry,
                debug: (0, env_1.isDebug)()
            });
            res.redirect(`/?${query}`);
        });
        this.app.get('/api/close', (req, res) => {
            res.writeHead(200);
            res.end();
            const { ok, reason } = url_1.default.parse(req.url, true).query;
            if (ok === 'true') {
                this.emit('link:success', JSON.parse(reason.toString()));
            }
            if ((0, env_1.isDevelopment)()) {
                return;
            }
            // we can't throw an error for this one, koa will handle and log it
            this.emit('link:error', new Error(`Failed to link: ${reason}`));
        });
    }
}
exports.LinkerAPI = LinkerAPI;
//# sourceMappingURL=LinkerAPI.js.map