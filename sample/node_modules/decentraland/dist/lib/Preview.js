"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Preview = void 0;
const path_1 = __importDefault(require("path"));
const ws_1 = __importDefault(require("ws"));
const child_process_1 = require("child_process");
const http_1 = require("http");
const events_1 = require("events");
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const portfinder_1 = __importDefault(require("portfinder"));
const glob_1 = __importDefault(require("glob"));
const chokidar_1 = __importDefault(require("chokidar"));
const url_1 = __importDefault(require("url"));
const ignore_1 = __importDefault(require("ignore"));
const schemas_1 = require("@dcl/schemas");
const broker_1 = __importDefault(require("./proto/broker"));
const errors_1 = require("../utils/errors");
const getDummyMappings_1 = __importDefault(require("../utils/getDummyMappings"));
/**
 * Events emitted by this class:
 *
 * preview:ready - The server is up and running
 */
class Preview extends events_1.EventEmitter {
    constructor(dcl, watch) {
        super();
        this.dcl = dcl;
        this.app = (0, express_1.default)();
        this.server = (0, http_1.createServer)(this.app);
        this.wss = new ws_1.default.Server({ server: this.server });
        this.watch = watch;
    }
    async startServer(port) {
        const relativiseUrl = (url) => {
            url = url.replace(/[\/\\]/g, '/');
            const newRoot = this.dcl
                .getWorkingDir()
                .replace(/\//g, '/')
                .replace(/\\/g, '/');
            if (newRoot.endsWith('/')) {
                return url.replace(newRoot, '');
            }
            else {
                return url.replace(newRoot + '/', '');
            }
        };
        let resolvedPort = port;
        if (!resolvedPort) {
            try {
                resolvedPort = await portfinder_1.default.getPortPromise();
            }
            catch (e) {
                resolvedPort = 2044;
            }
        }
        if (this.watch) {
            for (const project of this.dcl.workspace.getAllProjects()) {
                const ig = (0, ignore_1.default)().add((await project.getDCLIgnore()));
                const { sceneId, sceneType } = project.getInfo();
                chokidar_1.default
                    .watch(project.getProjectWorkingDir())
                    .on('all', (_, pathWatch) => {
                    if (ig.ignores(pathWatch)) {
                        return;
                    }
                    this.wss.clients.forEach((ws) => {
                        if (ws.readyState === ws_1.default.OPEN &&
                            (!ws.protocol || ws.protocol === 'scene-updates')) {
                            const message = {
                                type: schemas_1.sdk.SCENE_UPDATE,
                                payload: { sceneId, sceneType }
                            };
                            ws.send(schemas_1.sdk.UPDATE);
                            ws.send(JSON.stringify(message));
                        }
                    });
                });
            }
        }
        this.app.use((0, cors_1.default)());
        const npmModulesPath = path_1.default.resolve(this.dcl.getWorkingDir(), 'node_modules');
        // TODO: dcl.project.needsDependencies() should do this
        if (!fs_extra_1.default.pathExistsSync(npmModulesPath)) {
            (0, errors_1.fail)(errors_1.ErrorType.PREVIEW_ERROR, `Couldn\'t find ${npmModulesPath}, please run: npm install`);
        }
        const dclEcsPath = path_1.default.resolve(this.dcl.getWorkingDir(), 'node_modules', 'decentraland-ecs');
        const proxySetupPath = path_1.default.resolve(dclEcsPath, 'src', 'setupProxy.js');
        const dclApiPath = path_1.default.resolve(this.dcl.getWorkingDir(), 'node_modules', 'decentraland-api');
        const artifactPath = fs_extra_1.default.pathExistsSync(dclEcsPath) ? dclEcsPath : dclApiPath;
        const unityPath = path_1.default.resolve(dclEcsPath, 'artifacts', 'unity');
        if (fs_extra_1.default.existsSync(proxySetupPath)) {
            try {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const setupProxy = require(proxySetupPath);
                setupProxy(this.dcl, this.app, express_1.default);
            }
            catch (err) {
                console.log(`${proxySetupPath} found but it couldn't be loaded properly`, err);
            }
        }
        if (!fs_extra_1.default.pathExistsSync(artifactPath)) {
            (0, errors_1.fail)(errors_1.ErrorType.PREVIEW_ERROR, `Couldn\'t find ${dclApiPath} or ${dclEcsPath}, please run: npm install`);
        }
        this.app.get('/', async (req, res) => {
            res.setHeader('Content-Type', 'text/html');
            const htmlPath = path_1.default.resolve(artifactPath, 'artifacts/preview.html');
            const html = await fs_extra_1.default.readFile(htmlPath, {
                encoding: 'utf8'
            });
            res.send(html);
        });
        this.app.use('/@', express_1.default.static(artifactPath));
        this.app.use('/unity', express_1.default.static(unityPath));
        this.app.use('/contents/', express_1.default.static(this.dcl.getWorkingDir()));
        this.app.get('/mappings', (req, res) => {
            (0, glob_1.default)(this.dcl.getWorkingDir() + '/**/*', (err, files) => {
                if (err) {
                    res.status(500);
                    res.json(err);
                    res.end();
                }
                else {
                    const ret = (0, getDummyMappings_1.default)(files.map(relativiseUrl));
                    ret.contents = ret.contents.map(({ file, hash }) => ({
                        file,
                        hash: `contents/${hash}`
                    }));
                    res.json(ret);
                }
            });
        });
        this.app.get('/scene.json', (_, res) => {
            res.sendFile(path_1.default.join(this.dcl.getWorkingDir(), 'scene.json'));
        });
        this.app.use(express_1.default.static(path_1.default.join(artifactPath, 'artifacts')));
        setComms(this.wss);
        setDebugRunner(this.wss);
        this.emit('preview:ready', resolvedPort);
        return new Promise((resolve, reject) => {
            this.server.listen(resolvedPort).on('close', resolve).on('error', reject);
        });
    }
}
exports.Preview = Preview;
function setDebugRunner(wss) {
    wss.on('connection', (ws) => {
        if (ws.protocol === 'dcl-scene') {
            const file = require.resolve('dcl-node-runtime');
            const theFork = (0, child_process_1.fork)(file, [], {
                // enable two way IPC
                stdio: [0, 1, 2, 'ipc'],
                cwd: process.cwd()
            });
            console.log(`> Creating scene fork #` + theFork.pid);
            theFork.on('close', () => {
                if (ws.readyState === ws.OPEN) {
                    ws.close();
                }
            });
            theFork.on('message', (message) => {
                if (ws.readyState === ws.OPEN) {
                    ws.send(message);
                }
            });
            ws.on('message', (data) => theFork.send(data.toString()));
            ws.on('close', () => {
                console.log('> Killing fork #' + theFork.pid);
                theFork.kill();
            });
        }
    });
}
function setComms(wss) {
    const connections = new Set();
    const topicsPerConnection = new WeakMap();
    let connectionCounter = 0;
    const aliasToUserId = new Map();
    function getTopicList(socket) {
        let set = topicsPerConnection.get(socket);
        if (!set) {
            set = new Set();
            topicsPerConnection.set(socket, set);
        }
        return set;
    }
    wss.on('connection', function connection(ws, req) {
        if (ws.protocol !== 'comms') {
            return;
        }
        const alias = ++connectionCounter;
        const query = url_1.default.parse(req.url, true).query;
        const userId = query['identity'];
        aliasToUserId.set(alias, userId);
        console.log('Acquiring comms connection.');
        connections.add(ws);
        ws.on('message', (message) => {
            const data = message;
            const msgType = broker_1.default.CoordinatorMessage.deserializeBinary(data).getType();
            if (msgType === broker_1.default.MessageType.PING) {
                ws.send(data);
            }
            else if (msgType === broker_1.default.MessageType.TOPIC) {
                const topicMessage = broker_1.default.TopicMessage.deserializeBinary(data);
                const topic = topicMessage.getTopic();
                const topicFwMessage = new broker_1.default.TopicFWMessage();
                topicFwMessage.setType(broker_1.default.MessageType.TOPIC_FW);
                topicFwMessage.setFromAlias(alias);
                topicFwMessage.setBody(topicMessage.getBody_asU8());
                const topicData = topicFwMessage.serializeBinary();
                // Reliable/unreliable data
                connections.forEach(($) => {
                    if (ws !== $) {
                        if (getTopicList($).has(topic)) {
                            $.send(topicData);
                        }
                    }
                });
            }
            else if (msgType === broker_1.default.MessageType.TOPIC_IDENTITY) {
                const topicMessage = broker_1.default.TopicIdentityMessage.deserializeBinary(data);
                const topic = topicMessage.getTopic();
                const topicFwMessage = new broker_1.default.TopicIdentityFWMessage();
                topicFwMessage.setType(broker_1.default.MessageType.TOPIC_IDENTITY_FW);
                topicFwMessage.setFromAlias(alias);
                topicFwMessage.setIdentity(aliasToUserId.get(alias));
                topicFwMessage.setRole(broker_1.default.Role.CLIENT);
                topicFwMessage.setBody(topicMessage.getBody_asU8());
                const topicData = topicFwMessage.serializeBinary();
                // Reliable/unreliable data
                connections.forEach(($) => {
                    if (ws !== $) {
                        if (getTopicList($).has(topic)) {
                            $.send(topicData);
                        }
                    }
                });
            }
            else if (msgType === broker_1.default.MessageType.SUBSCRIPTION) {
                const topicMessage = broker_1.default.SubscriptionMessage.deserializeBinary(data);
                const rawTopics = topicMessage.getTopics();
                const topics = Buffer.from(rawTopics).toString('utf8');
                const set = getTopicList(ws);
                set.clear();
                topics.split(/\s+/g).forEach(($) => set.add($));
            }
        });
        ws.on('close', () => connections.delete(ws));
        setTimeout(() => {
            const welcome = new broker_1.default.WelcomeMessage();
            welcome.setType(broker_1.default.MessageType.WELCOME);
            welcome.setAlias(alias);
            const data = welcome.serializeBinary();
            ws.send(data);
        }, 100);
    });
}
//# sourceMappingURL=Preview.js.map